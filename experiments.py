#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module for the k-means cluster analysis of the travel ban news data for thesis

This module contains functions for running end-to-end experiments for the MS
thesis of the author. The algorithm used is MiniBatchKmeans from scikit-learn.
The data is read in JSON format matching o/p format of data.scraping module.

:REQUIRES:
    :./data/*: as generated by the data/scraping module
    :./config.json: [optional] default configuration used if absent

:TODO:
    complete the docstrings
    analysis of word-counts in articles vs lengths of the articles
    k-means model with googlenews pretrained doc2vec vectors

:AUTHOR: Parag Guruji
:ORGANIZATION: Purdue University
:CONTACT: pguruji@purdue.edu
:SINCE: Thu Dec 14 17:47:00 2017
:VERSION: 0.1
"""
# =============================================================================
# IMPORT STATEMENTS
# =============================================================================

from __future__ import print_function

import sys
import os
import warnings
import logging
import json
import re

import multiprocessing as mp
import numpy as np
import pandas as pd

from time import time
from datetime import datetime
from random import sample

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import MiniBatchKMeans
from sklearn import metrics

import matplotlib
matplotlib.use('agg')


# =============================================================================
# PROGRAM METADATA
# =============================================================================
__author__ = 'Parag Guruji'
__contact__ = 'pguruji@purdue.edu'
__copyright__ = 'Copyright (C) 2017 Parag Guruji, Purdue University, USA'
__date__ = 'Thu Dec 14 17:47:00 2017'
__version__ = '0.1'


# =============================================================================
# CLASSES / METHODS
# =============================================================================
DATA_DIR = os.path.join(os.getcwd(), "data")
logger = logging.getLogger(__name__)

'''
def validate(d):
    """Returns True if a data dict is valid for analysis.
    Validity is defined as the length of news text >= 280



    :param d: (*dict*) dict containing the news article data
    :returns: **True** if length(d.text) >= 280, **False** otherwise


    """

    if len(d['text']) < 280:
        return False
    return True


def preprocess(text):
    """Preprocesses given text and returns preprocessed text
    Strips everything but alphabets and converts to lowercase



    :param text: (*string*) text to preprocess
    :paaram returns: (*string*) preprocessed text


    """

    return ' '.join(map(lambda x: x.lower(),
                        re.split(r'[^a-zA-Z]+', text)))  # r'\W+'


def load_source_dicts(source):
    """Loads & preprocesses JSON data from directory of given news-source.
    Gives a list of JSON objects where each object corresponds to a unique,
    validated, & preprocessed news article.



    :param source: (*string*) subdirectory under thesis/data for a news-source
    :returns: (*list*) list of dicts for validated, preprocessed news articles.


    """

    _dicts = [json.load(open(os.path.join(DATA_DIR, source, f)))
              for f in os.listdir(os.path.join(DATA_DIR, source))
              if f.endswith('.dict')]
    valid_dicts = []
    for d in _dicts:
        if validate(d):
            d['text'] = preprocess(d['text'])
            d['source'] = source
            valid_dicts.append(d)
    return valid_dicts


def load_data(sources):
    """Loads data from sources through load_source_dicts and translates it to
    a pandas DataFrame



    :param sources: (*list*) list of news sources that are names of subdirectories under DATA_DIR
    :returns: (*pandas.DataFrame*) Dataframe - rows for articles, columns for attributes like text, title, publish_date, author


    """

    t0 = time()
    _list = json.load(open('data/lowercased_author_present_dicts.json', 'r'))
#            reduce(lambda x, y: x + y,
#                   map(load_source_dicts, sources))
    for i in range(len(_list)):
        _list[i]['uid'] = i+1
    logger.info("data loaded in %06.3fs\n" % (time() - t0))
    return pd.DataFrame.from_records(_list)
'''

def wc(D, M, C):
    """



    :param D:

    :param M:

    :param C:



    """

    return sum([((D[M == i] - C[i])**2).sum(axis=1).sum(axis=0)
                for i in set(M)])


'''
def _kmeans(D, K, max_iterations):
    """



    :param D:

    :param K:

    :param max_iterations:



    """

    C = np.array(sample(D, K))
    L_old = np.array([-1]*len(D))
    for _ in range(max_iterations):
        L = np.argmin(np.sqrt(((D - C[:, np.newaxis])**2).sum(axis=2)), axis=0)
        if all(L_old == L):
            break
        C = np.array(
                [D[L == l].mean(axis=0) if l in L else
                 np.array([np.inf]*D.shape[1])
                 for l in range(C.shape[0])])
        L_old = L.copy()
    return C, L
'''

def a_run(k, X, L, max_iterations, k_dir, c_dir, run):
    km = MiniBatchKMeans(init='k-means++', n_clusters=k, max_iter=max_iterations, batch_size=1200, n_init=4, max_no_improvement=10, verbose=0)
    t0 = time()
    km.fit(X)
    wcssd = wc(X.toarray(), km.labels_, km.cluster_centers_)
    purity = metrics.homogeneity_score(L, km.labels_)
    nmi = metrics.v_measure_score(L, km.labels_)
    t1 = time() - t0
    run_result = {"K": k, "Run": run, "WCSSD": wcssd, "Purity": purity, "NMI": nmi, "Time": t1, "Kmeans_Labels": km.labels_.tolist()}
    with open(os.path.join(k_dir, 'run' + str(run) + '.json'), "w") as runf:
        json.dump(run_result, runf)
    with open(os.path.join(c_dir, 'run' + str(run) + '.json'), "w") as ctrf:
        json.dump({"K": k, "Run": run, "Cluster_Centers": km.cluster_centers_.tolist()}, ctrf)
    logger.info(("K: %03d  Run: %03d  WCSSD: %015.8f  Purity: %015.8f  NMI: %015.8f  Time: %06.3fs") % (k, run, wcssd, purity, nmi, t1))
    return run_result


def experiment(X, K, L, max_iterations, run_count, run_timestamp='', _dir=None):
    """

    :param X:

    :param K:

    :param L:

    :param max_iterations:

    :param run_count:

    :param run_timestamp:  (Default value = '')

    :param _dir:  (Default value = None)


    """
    global_result = {}
    if not run_timestamp:
        run_timestamp = datetime.fromtimestamp(time()).strftime("%Y_%m_%d_%H_%M_%S")
    if not _dir:
        _dir = os.path.join('results', run_timestamp)
        _dirc = os.path.join('results', 'cluster_centers', run_timestamp)
    if not os.path.isdir(_dir):
        os.makedirs(_dir)
    if not os.path.isdir(_dirc):
        os.makedirs(_dirc)

    with warnings.catch_warnings():
        pool = mp.Pool(mp.cpu_count())
        warnings.simplefilter("ignore")
        for k in range(len(K)):
            k_dir = os.path.join(_dir, 'K' + str(K[k]))
            if not os.path.isdir(k_dir):
                os.makedirs(k_dir)
            c_dir = os.path.join(_dirc, 'K' + str(K[k]))
            if not os.path.isdir(c_dir):
                os.makedirs(c_dir)
            for run in range(run_count):
                pool.apply_async(a_run, args=(K[k], X, L, max_iterations, k_dir, c_dir, run))
        pool.close()
        pool.join()
        for k in range(len(K)):
            k_dir = os.path.join(_dir, 'K' + str(K[k]))
            runs_data = [json.load(open(os.path.join(k_dir, 'run' + str(run) + '.json'))) for run in range(run_count)]
            wcssds = [run["WCSSD"] for run in runs_data]
            mean_wcssd = np.mean(np.array(wcssds))
            std_dev_wcssd = np.std(np.array(wcssds))
            best_purity = max([run["Purity"] for run in runs_data])
            best_nmi = max([run["NMI"] for run in runs_data])
            global_result[K[k]] = {
                "K": K[k],
                "RunCount": run_count,
                "WCSSD-Mean": mean_wcssd,
                "WCSSD-Std-Dev": std_dev_wcssd,
                "Purity-Best": best_purity,
                "NMI-Best": best_nmi
            }
            logger.info(
                ("K: %03d  Runs: %03d  WCSSD-Mean: %015.8f  WCSSD-Std-Dev: %015.8f  Purity-Best: %015.8f  NMI-Best: %015.8f") %
                (K[k], run_count, mean_wcssd, std_dev_wcssd, best_purity, best_nmi))

        with open(os.path.join(_dir, 'global_result' + '.json'), "w") as gresf:
            json.dump(global_result, gresf)
    return _dir


def plot(_dir, run_count=30):
    table = []
    result_data = json.load(open(os.path.join(_dir, 'global_result' + '.json')))
    for k in result_data:
        table.append([
            result_data[k]["K"],
            result_data[k]["WCSSD-Mean"],
            result_data[k]["WCSSD-Std-Dev"],
            result_data[k]["Purity-Best"],
            result_data[k]["NMI-Best"]
        ])
    df = pd.DataFrame(table, columns=["K", "WCSSD-Mean", "WCSSD-Std-Dev", "Purity", "NMI"])
    df_sorted = df.sort_values(by='K', ascending=True)
    df_sorted.reset_index(drop=True)

    df_sorted.to_csv(os.path.join(_dir, 'plot_results.csv'), index=False)

    p1 = df_sorted.plot(x=df_sorted.columns.values[0], y=df_sorted.columns.values[1], title="Mean WC-SSD for %s Runs Vs. K" % run_count)
    p1.set_xticks(df_sorted[df_sorted.columns.values[0]], minor=True)
    p1.grid(which='both', linestyle='dotted', alpha=0.5)
    p1.get_figure().savefig(os.path.join(_dir, 'MeanWCSSDbyK.png'))

    p2 = df_sorted.plot(x=df_sorted.columns.values[0], y=df_sorted.columns.values[3], title="Purity Vs. K")
    p2.set_xticks(df_sorted[df_sorted.columns.values[0]], minor=True)
    p2.grid(which='both', linestyle='dotted', alpha=0.5)
    p2.get_figure().savefig(os.path.join(_dir, 'PuritybyK.png'))

    p3 = df_sorted.plot(x=df_sorted.columns.values[0], y=df_sorted.columns.values[4], title="NMI Vs. K")
    p3.set_xticks(df_sorted[df_sorted.columns.values[0]], minor=True)
    p3.grid(which='both', linestyle='dotted', alpha=0.5)
    p3.get_figure().savefig(os.path.join(_dir, 'NMIbyK.png'))

    return df, run_count, _dir


'''
            for run in range(run_count):
                t0 = time()
                km.fit(X)
                wcssd = wc(X.toarray(),
                           km.labels_,
                           km.cluster_centers_)
                purity = metrics.homogeneity_score(L, km.labels_)
                nmi = metrics.completeness_score(L, km.labels_)
                t1 = time() - t0
                run_result = {"K": K[k], "Run": run, "WCSSD": wcssd, "Purity": purity, "NMI": nmi, "Time": t1, "cluster_centers": km.cluster_centers_, "kmeans_labels": km.labels_}
                with open(os.path.join(k_dir, 'run' + str(run) + '.json'), "w") as runf:
                    json.dump(run_result, runf)
                logger.debug(("K: %03d  Run: %03d  WCSSD: %015.8f  Purity: %015.8f  NMI: %015.8f  Time: %06.3fs") %
                             (K[k], run, wcssd, purity, nmi, t1))
                result['runs'].append(run_result)
            t11 = time() - t00
            wcssds = [run["WCSSD"] for run in result["runs"]]
            mean_wcssd = np.mean(np.array(wcssds))
            std_dev_wcssd = np.std(np.array(wcssds))
            best_purity = max([run["Purity"] for run in result["runs"]])
            best_nmi = max([run["NMI"] for run in result["runs"]])
            with open(os.path.join(k_dir, 'summary_result' + '.json'), "w") as resf:
                json.dump({"K": K[k], "Runs": run_count, "WCSSD-Mean": mean_wcssd, "WCSSD-Std-Dev": std_dev_wcssd, "Purity-Best": best_purity, "NMI-Best": best_nmi, "Time": t11}, resf)
            logger.info(("K: %03d  Runs: %03d  WCSSD-Mean: %015.8f  WCSSD-Std-Dev: %015.8f  Purity-Best: %015.8f  NMI-Best: %015.8f  Time: %06.3fs") %
                        (K[k], run_count, mean_wcssd, std_dev_wcssd, best_purity, best_nmi, t11))
    return K, run_timestamp, _dir


            with open(os.path.join(_dir, 'K' + str(K[k]) + '.txt'), "w") as kf:
                kf.write(str(K[k]) + "\n")
                for run in range(run_count):
                    t0 = time()
                    km.fit(X)
                    wcssd = wc(X.toarray(),
                               km.labels_,
                               km.cluster_centers_)
                    t1 = time()
                    wcssds.append(wcssd)
                    logger.debug(("K: %03d  Run: %03d  WCSSD: %015.8f  Purity: %015.8f  NMI: %015.8f  Time: %06.3fs") %
                                 (K[k], run, wcssd, purity, nmi, (t1 - t0)))
                    kf.write("%s " % wcssd)





def analysis(K, run_timestamp='', _dir=None):
    """



    :param K:

    :param run_timestamp:  (Default value = '')

    :param _dir:  (Default value = None)



    """

    result = np.array([0.0]*(len(K)*3)).reshape(len(K), 3)
    if not _dir:
        _dir = os.path.join('results', run_timestamp)
    wcssds = []
    for k in range(len(K)):
        try:
            with open(os.path.join(_dir, 'K' + str(K[k]) + '.txt'), "r") as kf:
                k_f = int(kf.next())
                if K[k] == k_f:
                    wcssds = map(float, kf.next().split())
                    result[k][0] = K[k]
                    result[k][1] = np.mean(wcssds)
                    result[k][2] = np.std(wcssds)
                else:
                    logger.fatal("Expected K: %s, found %s" % (K[k], k_f))
                    break
        except IOError:
            logger.error("IOError in results for K=%s" % K[k], exc_info=True)
    run_count = len(wcssds)
    df = pd.DataFrame(result, columns=['K', 'Mean-WC-SSD', 'STD-WC-SSD'])
    df.to_csv(os.path.join(_dir, 'results.csv'), index=False)
    return df, run_timestamp, run_count, _dir


def plot1(df=None, run_timestamp='', run_count=0, _dir=None):
    """



    :param df:  (Default value = None)

    :param run_timestamp:  (Default value = '')

    :param run_count:  (Default value = 0)

    :param _dir:  (Default value = None)



    """

    if not _dir:
        _dir = os.path.join('results', run_timestamp)
    if df is None:
        df = pd.read_csv(os.path.join(_dir, 'results.csv'))
    p1 = df.plot(x=df.columns.values[0],
                 y=df.columns.values[1],
#                 yerr=df.columns.values[2],
                 title="Mean WC-SSD for %s Runs Vs. K" % run_count)
    p1.set_xticks(df[df.columns.values[0]], minor=True)
    p1.grid(which='both', linestyle='dotted', alpha=0.5)
    p1.get_figure().savefig(os.path.join(_dir, 'Mean-WC-SSD.png'))
'''


def build_setup(config=None):
    """



    :param config:  (Default value = None)



    """

    setup = {}
    if config is None:
        try:
            config = json.load(open('config.json'))
        except Exception:
            config = {}
            logger.error("config failed, using defaults", exc_info=True)


#    df = load_data(config.get('sources',
#                              ['cnn',
#                               'foxnews',
#                               'nytimes',
#                               'nypost',
#                               'bostonglobe',
#                               'chicagotribune',
#                               'latimes',
#                               'wallstreetjournal',
#                               'washingtonpost']))


    data = json.load(open('clean_data.json'))

    vectorizer = TfidfVectorizer(max_df=config.get('max_df', 0.1),
                                 max_features=config.get('max_features', 1200),
                                 min_df=config.get('min_df', 1),
                                 stop_words=config.get('stop_words',
                                                       'english'),
                                 use_idf=config.get('use_idf', True),
                                 analyzer=config.get('analyzer', 'word'),
                                 ngram_range=tuple(config.get('ngram_range',
                                                              (2, 3))))

    setup['X'] = vectorizer.fit_transform([d['text'] for d in data])
    setup['K'] = config.get('K', range(2, 701, 1))
    setup['K'] = range(*config.get('k_range', [2, 701, 1]))
    setup['L'] = [d['source'] for d in data]
    setup['max_iterations'] = config.get('max_iterations', 50)
    setup['run_count'] = config.get('run_count', 50)
    setup['run_timestamp'] = datetime.fromtimestamp(time()).strftime("%Y_%m_%d_%H_%M_%S")

    _dir = os.path.join(os.getcwd(), 'results', setup['run_timestamp'])
    if not os.path.isdir(_dir):
        os.makedirs(_dir)
    json.dump(config,
              open(os.path.join(_dir, setup['run_timestamp'] + ".config"), "w"))
    logFilePath = os.path.join(_dir, setup['run_timestamp'] + ".log")

    formatter = logging.Formatter('%(asctime)s:%(levelname)s: %(message)s')
    stream_handler = logging.StreamHandler()
    stream_handler.setLevel(logging.INFO)
    stream_handler.setFormatter(formatter)

    file_handler = logging.FileHandler(filename=logFilePath)
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    logger.addHandler(file_handler)
    logger.addHandler(stream_handler)

    logger.info("Logging for experiment started at %s" % setup['run_timestamp'])

    return setup


# =============================================================================
# MAIN METHOD AND TESTING AREA
# =============================================================================


def main(config=None):
    """Description of main()



    :param config:  (Default value = None)

    params of experiment: X, K, L, max_iterations, run_count, run_timestamp='', _dir=None

    """

    setup = build_setup()
    t0 = time()
    result_dir = experiment(**setup)
#    plot(*analysis(K=setup['K'], run_timestamp=setup['run_timestamp']))
    plot(result_dir, setup['run_count'])
    X = setup.pop('X')
    with open(os.path.join(result_dir, 'setup.json'), "w") as sf:
        json.dump(setup, sf)
    logger.setLevel(logging.INFO)
    logger.info("Experiments completed in %fs" % (time() - t0))


def multiprocess_main(config=None):
    """



    :param config:  (Default value = None)



    """

    setup = build_setup()
    pool = mp.Pool(mp.cpu_count())
    logger.setLevel(logging.ERROR)
    t0 = time()
    for k in setup['K']:
        pool.apply_async(experiment,
                         args=(setup['X'],
                               [k],
                               setup['max_iterations'],
                               setup['run_count'],
                               setup['run_timestamp']))

    pool.close()
    pool.join()
    logger.setLevel(logging.INFO)
    plot(*analysis(K=setup['K'], run_timestamp=setup['run_timestamp']))
    logger.info("Multiprocess completed in %fs" % (time() - t0))


if __name__ == '__main__':
    config = None
    if len(sys.argv) > 1:
        try:
            config = json.load(open(sys.argv[1]))
        except Exception:
            logger.error("Provided config file failed, trying default file")
    main(config)
#    multiprocess_main(config)
